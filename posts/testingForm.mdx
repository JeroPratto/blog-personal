---
title: 'Testing de un formulario en React'
subtitle: 'C贸mo testear un formulario en React usando las librer铆as de Testing Library y jest. '
description: 'Aprende a realizar pruebas a formularios en React con las herramientas Render, Screen, Expect, y Mocks. Simplifica el proceso de prueba y verifica la funcionalidad de tus formularios de manera efectiva. 隆Asegura la calidad de tu c贸digo con tests precisos y confiables!'
date: '2023-04-17'
urlImg: 'testing-formulario-react.jpg'
---

<small>2023-04-17</small>

# Testing de un formulario en React

En este post, se explica c贸mo utilizar screen, render y expect para realizar pruebas a un formulario en React.

## Render, Screen, Expect, Mocks

- Render

Como su nombre indica, lo que va a hacer esto es renderizar el componente que nosotros le pidamos y nos va a retornar el contenedor del DOM donde se est谩 ejecutando la prueba. Para simplificar la explicaci贸n, imag铆nate un vac铆o (navegador) y dentro de este aparece el componente que renderizaste y eso es lo unico que hay. A partir de ah铆, vamos a poder empezar a trabajar.

- Screen

screen es una utilidad que nos permite actuar sobre el contenedor renderizado. Proporciona m茅todos para buscar elementos en el DOM, como getByRole, getByTestId, etc. Esto facilita la interacci贸n y la b煤squeda de elementos espec铆ficos para las pruebas.

- Expect

La funci贸n expect se utiliza para hacer afirmaciones sobre los elementos del DOM. En la primera parte de la afirmaci贸n, se indica qu茅 elemento se va a observar, y en la segunda parte se especifica qu茅 se espera que suceda. Por ejemplo, expect(elemento).toBeInTheDocument() verifica si el elemento est谩 presente en el documento.

- Mocks

Los mocks son datos controlados que se proporcionan a los componentes para obtener respuestas predecibles durante las pruebas.

## Carpetas y archivos a crear

- \_\_test\_\_
  - LoginForm.test.tsx
- \_\_mocks\_\_
  - LoginForm.mock.ts

## Ejemplo b谩sico

```tsx:LoginForm.test.tsx
import { render } from '@testing-library/react'

// describe(nombreComponente, logica)

describe('LoginForm', () => {
	// Vamos a tomar "it" como cada parte individual del test.
	it('should render correctly', () => {
		const container = render(<LoginForm />) // renderiza <LoginForm/>
		expect(container).toBeInTheDocument() // Si container esta en el documento pasa el test
	})
})
```

Ya sabiendo la base de c贸mo vamos a realizar los tests, podemos comenzar a complejizarlos.

## Creaci贸n de mocks

```ts:LoginForm.mock.ts
// Esta va a ser la informaci贸n "buena"
export const LoginFormMock = {
	username: 'username',
	password: 'pass123@',
}

// Esta va a ser la informaci贸n erronea
export const LoginFormMockError = {
	username: 'usernameeeeeeeeeeeeeee',
	password: 'pass123',
}
```

## Dos inputs en pantalla

```tsx:LoginForm.test.tsx
import { screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { LoginFormMock } from '@/__mocks__/LoginForm.mock.ts'

describe('LoginForm', () => {
	// se ejecuta despues del test y resetea los mocks
	afterEach(cleanup)
	afterEach(jest.clearAllMocks)
	// Este beforeEach es para que se ejecute siempre antes de cualquier test y no tener que repetir constantemente el render
	beforeEach(() => {
		render(<LoginForm />)
	})
	it('should two input and button exists at the screen', () => {
		// Obtenemos los elementos por su rol y name, aunque hay otras formas como el data-testid
		const usernameInput = screen.getByRole('textbox', { name: /Iniciar sesion/i, })
		const passwordInput = screen.getByRole('textbox', { name: /Contrase帽a/i })
		const buttonSubmit = screen.getByRole('button', { name: /Iniciar sesion/i })

		expect(usernameInput).toBeInTheDocument()
		expect(passwordInput).toBeInTheDocument()
		expect(buttonSubmit).toBeInTheDocument()

		// Aca verifica si el bot贸n est谩 deshabilitado cuando el form no tiene informaci贸n.
		expect(buttonSubmit).toBeDisabled()
	})
```

### Mismos dos inputs y le sumamos mocks, userEvent

```jsx
	it('should enable the submit button if the form values are valid', async () => {
		const usernameInput = screen.getByRole('textbox', { name: /Iniciar sesion/i, })
		const passwordInput = screen.getByRole('textbox', { name: /Contrase帽a/i })
		const submitButton = screen.getByRole('button', { name: /Iniciar sesion/i })

		expect(submitButton).tobeDisabled()

		// Ahora simulamos que el usuario escribe en el form con la informaci贸n del mock
		await userEvent.type(usernameInput, LoginFormMock.username)
		await userEvent.type(usernameInput, LoginFormMock.password)

		// El waitFor es una funci贸n que espera a que todo lo que est谩 dentro termine; aqu铆 no se utiliza de la mejor manera
		// pero es para el ejemplo
		await waitFor(() => {
			// Vemos si el valor del form conincide con el mock
			expect(usernameInput).toHaveValue(LoginFormMock.username)
			expect(passwordInput).toHaveValue(LoginFormMock.password)
		})
		// y vemos que se habilite el boton
		expect(submitButton).toBeEnabled()
	})
})
```
